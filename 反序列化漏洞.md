# 反序列化漏洞

- 序列化与反序列化：


  ​	序列化（Serialization）是将对象的状态信息转化为可以存储或者传输的形式的过程，一般将一个对象存储到一个储存媒介，例如档案或记忆体缓冲等，在网络传输过程中，可以是字节或者XML等格式；而字节或者XML格式的可以还原成完全相等的对象，这个相反的过程又称为反序列化。

- 对象序列化机制：

  ​	对象序列化机制（object serialization）是java语言内建的一种对象持久化方式，通过对象序列化，可以将对象的状态信息保存为字节数组，并且可以在需要时，将这个字节数组通过反序列化的方式转换成对象，对象的序列化可以很容易的在JVM中的活动对象和字节数组（流）之间进行转换。在JAVA中，对象的序列化和反序列化被广泛的应用到RMI（远程方法调用）及网络传输中。

- Serialization接口详解：

  ​	Java类通过实现java.io.Serialization接口来启用序列化功能。下边是应用序列化与反序列化的代码样例。

  ```
  package sun;
  
  import java.io.IOException;
  import java.io.Serializable;
  
  
  public class user implements Serializable {
  
      private String name;
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
  }
  ```

  ​	通过下边的操作来实现序列化与反序列化。

  ```
  package sun;
  
  import java.io.*;
  
  
  public class SerializableDemo {
  
      public static void main(String[] args) throws Exception, IOException{
  
          //初始化对象
          user user_one = new user();
          user_one.setName("sunqing");
          System.out.println(user_one.getName());
  
          //序列化对象到文件中
          FileOutputStream fos = new FileOutputStream("sun");
          ObjectOutputStream oos = new ObjectOutputStream(fos);
          oos.writeObject(user_one);
          oos.close();
          fos.close();
  
          //反序列化
          File file = new File("sun");
          FileInputStream fis = new FileInputStream(file);
          ObjectInputStream ois = new ObjectInputStream(fis);
          user user_two = (user)ois.readObject();
          ois.close();
          fis.close();
          System.out.println(user_two.getName());
  
      }
  }
  ```

- ReadObject方法

  ​	着重讲一下ReadObject方法，如果ReadObject方法被序列化的类重写，虚拟机在反序列化的过程中，会调用被反序列化类的ReadObject方法。

  ​	也就是说如果在user类中重写了readObject方法，虚拟机在反序列化过程中会运用user类中的ReadObject方法。下边代码进行在user类中对ReadObject方法进行重写。运行时，会执行calc的弹窗。

```
package sun;

import java.io.IOException;
import java.io.Serializable;


public class user implements Serializable {

    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    private void readObject(java.io.ObjectInputStream in) throws ClassNotFoundException, IOException {

        // 使用原来的ReadObject方法
        in.defaultReadObject();

        //弹窗测试
        Runtime.getRuntime().exec("calc");
    }
}
```

​	这里就知道反序列化漏洞存在，可以通过重写被序列化类的ReadObject方法来实现。但是一般的程序员都不会直接将执行命令写在ReadObject中，此处就通过反射链来进行任意代码执行的。

- Java的反射机制

  ​	反射就是在运行状态中，对于任意的一个类，都能够知道这个类的所有的属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并能改变它的属性。




- 这类机制存在的漏洞有很多种
  - [ ] 如果反序列化未授信的数据，就可能导致代码执行，进而进行一些恶意的操作。
  - [ ] 在编写程序时，如果对于继承使用不当，就可能将存在敏感信息的对象进行序列化，序列化的数据可能被劫持并泄露敏感信息。
  - [ ] 在Java反序列化中，会调用被反序列化的readObject方法，当readObject方法书写不当时就会引发漏洞。















## 敏感信息序列化 CWE499_Sensitive_Data_Serializable

###### 漏洞描述

- ​	CWE499是由于java的反序列化机制导致的漏洞，由于对于继承使用不当，可能将敏感数据进行序列化，进而导致敏感信息泄露。

###### 漏洞代码

- ​	下边是漏洞代码，选用Juliet_Test_Suite_v1.3_for_Java 测试集，文件目录在Juliet_Test_Suite_v1.3_for_Java\Java\src\testcases\CWE499_Sensitive_Data_Serializable\CWE499_Sensitive_Data_Serializable__serializable_01_bad.java

```
package testcases.CWE499_Sensitive_Data_Serializable;

import java.sql.*;
import java.io.*;
import java.util.logging.Level;
import testcasesupport.*;


/* FLAW: Class extends a serializable class, does not explicitly deny serialization, and contains sensitive data. */ 
public class CWE499_Sensitive_Data_Serializable__serializable_01_bad extends CWE499_Sensitive_Data_Serializable__serializable_Helper
{    
    /* Sensitive field */
    private String passwordHash;
    
    protected void setPassword(String password)
    {
        passwordHash = password;
    }
    
    protected String getPassword()
    {
        return passwordHash;
    }
}
```

###### 漏洞成因

- ​	大概的意思是，第十行定义的**01_bad**这个类，是继承的父类 **Helper** ，而 **Helper** 是一个可以序列化的类，实现java.io.Serializable接口。那么在序列化这个**01_bad**类的时候就会**将隐私数据也序列化**，就是其中第十三行的 passwordHash 这个变量，如果攻击者可以获取到序列化的数据就有可能进行还原，进而获取到敏感信息。
- 可能是对于数据库中数据的定义类，例如：医患用户的id，家庭地址，电话等等信息。

###### 漏洞修复

- ​	如何进行漏洞的修复呢，大概有两种思路。
- 一是将父类的序列化操作进行重写，如果发现序列化的操作就抛异常，停止执行；
- 二是将敏感变量加上transient关键字，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。

###### 修复代码1

- 将敏感变量加上transient关键字

```
package testcases.CWE499_Sensitive_Data_Serializable;

import java.sql.*;
import java.io.*;
import java.util.logging.Level;
import testcasesupport.*;

/* We would never expect to see a real class like this, but our implementation tries to ensure the fact
 * that one of the fields is sensitive */
public class CWE499_Sensitive_Data_Serializable__serializable_01_good2 extends CWE499_Sensitive_Data_Serializable__serializable_Helper
{
    /* FIX: Use the transient keyword to deny serialization */
    /* Sensitive field */
    private transient String passwordHash;
    
    protected void setPassword(String password)
    {
        passwordHash = password;
    }
    
    protected String getPassword()
    {
        return passwordHash;
    }
}
```

###### 修复代码2

- 将父类的序列化相关操作重写，如果子类执行序列化操作就抛异常。

```
package testcases.CWE499_Sensitive_Data_Serializable;

import java.sql.*;
import java.io.*;
import java.util.logging.Level;
import testcasesupport.*;


public class CWE499_Sensitive_Data_Serializable__serializable_01_good1 extends CWE499_Sensitive_Data_Serializable__serializable_Helper 
{
    /* Sensitive field */
    private String passwordHash;
    
    protected void setPassword(String password)
    {
        passwordHash = password;
    }
    
    protected String getPassword()
    {
        return passwordHash;
    }

    /* FIX: Override writeObject(), readObject(),  and readObjectNoData() methods to deny serialization attempts */
    private final void writeObject(ObjectOutputStream out) throws IOException
    {
        throw new NotSerializableException();
    }
    
    private final void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException
    {
        throw new NotSerializableException();
    }
	
	private final void readObjectNoData() throws ObjectStreamException
	{
        throw new NotSerializableException();
    }
}
```

